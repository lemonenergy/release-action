/** Released under the Apache-2.0 License, @tunnckoCore <opensource@tunnckocore.com> & contributors. */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isExtendable = function isExtendable(val) {
  return typeof val !== 'undefined' && val !== null && (typeof val === 'object' || typeof val === 'function');
};

var forIn = function forIn(obj, fn, thisArg) {
  for (var key in obj) {
    if (fn.call(thisArg, obj[key], key, obj) === false) {
      break;
    }
  }
};

function mixinDeep(target, objects) {
  var len = arguments.length,
      i = 0;

  while (++i < len) {
    var obj = arguments[i];

    if (isObject(obj)) {
      forIn(obj, copy, target);
    }
  }

  return target;
}

function copy(val, key) {
  if (key === '__proto__') {
    return;
  }

  var obj = this[key];

  if (isObject(val) && isObject(obj)) {
    mixinDeep(obj, val);
  } else {
    this[key] = val;
  }
}

function isObject(val) {
  return isExtendable(val) && !Array.isArray(val);
}

var mixinDeep_1 = mixinDeep;

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var mentionsRegex = function mentionsRegex(dot) {
  if (dot) {
    return /(?:^|[^a-zA-Z0-9_＠!@#$%&*])(?:(?:@|＠)(?!\/))([a-zA-Z0-9/_.]{1,15})(?:\b(?!@|＠)|$)/;
  }

  return /(?:^|[^a-zA-Z0-9_＠!@#$%&*])(?:(?:@|＠)(?!\/))([a-zA-Z0-9/_]{1,15})(?:\b(?!@|＠)|$)/;
};

var dist = createCommonjsModule(function (module, exports) {
/**
 * @copyright 2017-present, Charlike Mike Reagent (https://i.am.charlike.online)
 * @license Apache-2.0
 */

const mentionsRegex$1 = (m => m.__esModule ? m.default : m)(mentionsRegex);

function getMentions(str, dot) {
  const result = [];
  const regex = new RegExp(mentionsRegex$1(dot), 'g');
  let m = null;

  while (m = regex.exec(str)) {
    result.push({
      handle: m[0].trim(),
      mention: m[1],
      index: m.index
    });
  }

  return result;
}

Object.defineProperty(exports, '__esModule', {
  value: true
}).default = getMentions;
});

const getMentions = unwrapExports(dist);

const errorMsg = `parse-commit-message: expect \`commit\` to follow:
<type>[optional scope]: <description>

[optional body]

[optional footer]`;
function isValidString(x) {
  return Boolean(x && typeof x === 'string' && x.length > 0);
}
function stringToHeader(val, caseSensitive) {
  const sensitive = caseSensitive || false;
  const regex = sensitive ? /^(\w+)(?:\((.+)\))?(!)?: (.+)/ : /^(\w+)(?:\((.+)\))?(!)?: (.+)/i;

  if (!regex.test(val)) {
    throw new TypeError(errorMsg);
  }

  const matches = regex.exec(val).slice(1);

  if (!matches) {
    throw new Error(errorMsg);
  }

  const [type, scope = null, bang, subject] = matches;
  return {
    type,
    scope,
    subject
  };
}
function normalizeCommit(commit) {
  const {
    header
  } = commit;

  if (header && typeof header === 'object' && 'value' in header) {
    return Object.assign({}, commit, {
      header: stringToHeader(header.value)
    });
  }

  return commit;
}
function getValue(obj, key) {
  return key in obj ? obj[key] : '';
}
function toArray(val) {
  if (!val) return [];
  if (Array.isArray(val)) return val;
  return [val];
}

function mentions(commit) {
  const cmt = normalizeCommit(commit);
  const commitMentions = [].concat(getMentions(getValue(cmt.header, 'subject'))).concat(getMentions(cmt.body)).concat(getMentions(cmt.footer));
  return {
    mentions: commitMentions
  };
}

function increment(commit) {
  const cmt = normalizeCommit(commit);
  let isBreaking = isBreakingChange(cmt);
  let commitIncrement = '';
  const type = getValue(cmt.header, 'type');

  if (/fix|bugfix|patch/i.test(type)) {
    commitIncrement = 'patch';
  }

  if (/feat|feature|minor/i.test(type)) {
    commitIncrement = 'minor';
  }

  if (/break|breaking|major/i.test(type) || isBreaking) {
    commitIncrement = 'major';
  }

  isBreaking = isBreaking || commitIncrement === 'major';
  return {
    increment: commitIncrement,
    isBreaking
  };
}

function isBreakingChange(commit) {
  const re = /^BREAKING\s+CHANGES?:\s+/;
  return re.test(getValue(commit.header, 'subject')) || re.test(commit.body || '') || re.test(commit.footer || '');
}

function parseHeader(header) {
  if (!isValidString(header)) {
    throw new TypeError('expect `header` to be non empty string');
  }

  return stringToHeader(header.trim());
}
function stringifyHeader(header) {
  const res = validateHeader(header);

  if (res.error) {
    throw res.error;
  }

  if (res.value && typeof res.value === 'object' && 'value' in res.value) {
    return res.value.value;
  }

  const {
    type,
    scope,
    subject
  } = res.value;
  return `${type}${scope ? `(${scope})` : ''}: ${subject}`.trim();
}
function validateHeader(header) {
  const result = {};

  try {
    result.value = checkHeader(header);
  } catch (err) {
    return {
      error: err
    };
  }

  return result;
}
function checkHeader(header, caseSensitive) {
  const sensitive = caseSensitive || false;

  if (header === null || header === undefined) {
    throw new Error(errorMsg);
  }

  if (typeof header === 'object' && 'value' in header) {
    const {
      value
    } = header;
    return stringToHeader(value, sensitive);
  }

  if (!isValidString(header.type)) {
    throw new TypeError('header.type should be non empty string');
  }

  if (!isValidString(header.subject)) {
    throw new TypeError('header.subject should be non empty string');
  }

  const isValidScope = 'scope' in header && header.scope !== null ? isValidString(header.scope) : true;

  if (!isValidScope) {
    throw new TypeError('commit.header.scope should be non empty string when given');
  }

  return Object.assign({
    scope: null
  }, header);
}

function parseCommit(commit) {
  if (!isValidString(commit)) {
    throw new TypeError(`expect \`commit\` to be non empty string`);
  }

  const header = parseHeader(commit);
  const [body = null, footer = null] = commit.split('\n\n').slice(1);
  return {
    header,
    body,
    footer
  };
}
function stringifyCommit(commit) {
  const result = validateCommit(commit);

  if (result.error) {
    throw result.error;
  }

  const header = stringifyHeader(result.value.header);
  const EOL = '\n';
  result.value.body = result.value.body ? EOL + EOL + result.value.body : '';
  result.value.footer = result.value.footer ? EOL + EOL + result.value.footer : '';
  return `${header}${result.value.body}${result.value.footer}`;
}
function validateCommit(commit) {
  const result = {};

  try {
    result.value = checkCommit(commit);
  } catch (err) {
    return {
      error: err
    };
  }

  return result;
}
function checkCommit(commit) {
  const {
    error,
    value: headerObj
  } = validateHeader(commit.header);

  if (error) {
    throw error;
  }

  const isValidBody = 'body' in commit && commit.body !== null ? typeof commit.body === 'string' : true;

  if (!isValidBody) {
    throw new TypeError('commit.body should be string when given');
  }

  const isValid = 'footer' in commit && commit.footer !== null ? typeof commit.footer === 'string' : true;

  if (!isValid) {
    throw new TypeError('commit.footer should be string when given');
  }

  return Object.assign({
    body: null,
    footer: null
  }, commit, {
    header: headerObj
  });
}

function parse(commits) {
  const result = toArray(commits).filter(Boolean).reduce((acc, val) => {
    if (typeof val === 'string') {
      return acc.concat(parseCommit(val));
    }

    if (typeof val === 'object' && !Array.isArray(val)) {
      return acc.concat(val);
    }

    return acc.concat(parse(val));
  }, []);
  return result;
}
function stringify(commits) {
  const result = toArray(commits).filter(Boolean).reduce((acc, val) => acc.concat(toArray(check(typeof val === 'string' ? {
    header: {
      value: val
    }
  } : val)).map(x => stringifyCommit(x))), []);
  return result;
}
function validate(commits) {
  const result = {};

  try {
    result.value = check(commits);
  } catch (err) {
    return {
      error: err
    };
  }

  return result;
}
function check(commits) {
  const result = toArray(commits).reduce((acc, commit) => {
    if (typeof commit === 'string') {
      commit = parseCommit(commit);
    }

    return acc.concat(checkCommit(commit));
  }, []);

  if (result.length === 0) {
    throw new Error(errorMsg);
  }

  return result;
}

function applyPlugins(plugins, commits) {
  const arr = [];
  const cmts = [];
  const plgs = arr.concat(plugins).filter(Boolean);
  return cmts.concat(commits).filter(Boolean).reduce((result, commit) => {
    let commitObject = {};

    if (typeof commit === 'string') {
      commitObject = {
        header: {
          value: commit
        }
      };
    } else if (typeof commit === 'object' && !Array.isArray(commit)) {
      commitObject = commit;
    }

    const cmt = plgs.reduce((acc, fn) => {
      const res = fn(acc);
      return mixinDeep_1(acc, res);
    }, commitObject);
    return result.concat(cmt);
  }, []);
}
const plugins = [mentions, increment];
const mappers = {
  mentions,
  increment
};

exports.applyPlugins = applyPlugins;
exports.plugins = plugins;
exports.mappers = mappers;
exports.parse = parse;
exports.stringify = stringify;
exports.validate = validate;
exports.check = check;
exports.parseHeader = parseHeader;
exports.stringifyHeader = stringifyHeader;
exports.validateHeader = validateHeader;
exports.checkHeader = checkHeader;
exports.parseCommit = parseCommit;
exports.stringifyCommit = stringifyCommit;
exports.validateCommit = validateCommit;
exports.checkCommit = checkCommit;
exports.stringToHeader = stringToHeader;
exports.toArray = toArray;

module.exports = exports.default || exports;
